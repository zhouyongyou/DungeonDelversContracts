{
  "language": "Solidity",
  "sources": {
    "VRFManagerV2PlusFixed.sol": {
      "content": "// VRFManagerV2PlusFixed.sol - 正確使用 BNB Direct Funding 模式\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../interfaces/interfaces.sol\";\n\n/**\n * @title VRFManagerV2PlusFixed\n * @notice 正確實現 Chainlink VRF V2.5 Direct Funding（使用 BNB 而非 LINK）\n * @dev 繼承 VRFV2PlusWrapperConsumerBase，使用 requestRandomnessPayInNative\n */\ncontract VRFManagerV2PlusFixed is VRFV2PlusWrapperConsumerBase, IVRFManager, Ownable, ReentrancyGuard {\n    using Strings for uint256;\n    \n    // VRF 配置\n    uint32 public callbackGasLimit = 500000;\n    uint16 public requestConfirmations = 3;\n    uint256 public platformFee = 0.0003 ether;\n    uint256 public vrfRequestPrice = 0.005 ether; // 預估 VRF 費用\n    \n    // 存儲\n    mapping(uint256 => RandomRequest) private _requests;\n    mapping(address => bool) public authorizedContracts;\n    mapping(address => uint256) public userToRequestId;\n    mapping(address => uint256[]) public userRandomWords;\n    \n    // 事件\n    event RandomRequested(uint256 indexed requestId, address indexed requester, RequestType requestType);\n    event RandomFulfilled(uint256 indexed requestId, uint256[] randomWords);\n    event AuthorizationUpdated(address indexed contract_, bool authorized);\n    event VRFPriceUpdated(uint256 newPrice);\n    event PlatformFeeUpdated(uint256 newFee);\n    \n    modifier onlyAuthorized() {\n        require(authorizedContracts[msg.sender], \"Not authorized\");\n        _;\n    }\n    \n    /**\n     * @dev 構造函數\n     * @param _wrapperAddress BSC Mainnet V2Plus Wrapper 地址\n     */\n    constructor(address _wrapperAddress) \n        VRFV2PlusWrapperConsumerBase(_wrapperAddress)\n        Ownable(msg.sender)\n    {\n        // 初始化\n    }\n    \n    // ============================================\n    // IVRFManager 介面實現\n    // ============================================\n    \n    /**\n     * @notice 獲取請求信息（實現 IVRFManager）\n     */\n    function requests(uint256 requestId) external view override returns (RandomRequest memory) {\n        return _requests[requestId];\n    }\n    \n    /**\n     * @notice 獲取 VRF 請求價格（實現 IVRFManager）\n     */\n    function getVrfRequestPrice() external view override returns (uint256) {\n        return vrfRequestPrice;\n    }\n    \n    /**\n     * @notice 為用戶請求隨機數（Hero/Relic 鑄造專用）\n     * @dev 使用 BNB 支付而非 LINK\n     */\n    function requestRandomForUser(\n        address user,\n        uint256 quantity,\n        uint8 maxRarity,\n        bytes32 commitment\n    ) external payable override onlyAuthorized nonReentrant returns (uint256 requestId) {\n        // 計算實際 VRF 費用（使用 Native BNB）\n        uint256 actualVrfPrice = i_vrfV2PlusWrapper.calculateRequestPriceNative(\n            callbackGasLimit,\n            uint32(quantity)\n        );\n        \n        // 總費用 = VRF 費用 + 平台費\n        uint256 totalFee = actualVrfPrice + platformFee;\n        require(msg.value >= totalFee, \"Insufficient fee\");\n        \n        // 使用 BNB 請求隨機數（關鍵改動：使用 requestRandomnessPayInNative）\n        // V2.5 需要正確格式化 extraArgs\n        bytes memory extraArgs = abi.encodePacked(uint8(1)); // nativePayment = true\n        (requestId, ) = requestRandomnessPayInNative(\n            callbackGasLimit,\n            requestConfirmations,\n            uint32(quantity),\n            extraArgs\n        );\n        \n        // 存儲請求信息\n        bytes memory data = abi.encode(user, quantity, maxRarity, commitment);\n        _requests[requestId] = RandomRequest({\n            requester: msg.sender,\n            requestType: RequestType.HERO_MINT,\n            data: data,\n            fulfilled: false,\n            randomWords: new uint256[](0)\n        });\n        \n        // 存儲用戶映射\n        userToRequestId[user] = requestId;\n        \n        // 退還多餘費用\n        if (msg.value > totalFee) {\n            payable(msg.sender).transfer(msg.value - totalFee);\n        }\n        \n        emit RandomRequested(requestId, msg.sender, RequestType.HERO_MINT);\n    }\n    \n    /**\n     * @notice 獲取用戶的隨機數結果\n     */\n    function getRandomForUser(address user) external view override returns (\n        bool fulfilled,\n        uint256[] memory randomWords\n    ) {\n        uint256 requestId = userToRequestId[user];\n        if (requestId == 0) {\n            return (false, new uint256[](0));\n        }\n        \n        RandomRequest memory request = _requests[requestId];\n        return (request.fulfilled, request.randomWords);\n    }\n    \n    /**\n     * @notice 通用隨機數請求（實現 IVRFManager）\n     * @dev 使用 BNB 支付\n     */\n    function requestRandomness(\n        RequestType requestType,\n        uint32 numWords,\n        bytes calldata data\n    ) external payable override onlyAuthorized nonReentrant returns (uint256 requestId) {\n        // 計算實際 VRF 費用\n        uint256 actualVrfPrice = i_vrfV2PlusWrapper.calculateRequestPriceNative(\n            callbackGasLimit,\n            numWords\n        );\n        \n        // 總費用 = VRF 費用 + 平台費\n        uint256 totalFee = actualVrfPrice + platformFee;\n        require(msg.value >= totalFee, \"Insufficient fee\");\n        \n        // 使用 BNB 請求隨機數\n        bytes memory extraArgs = abi.encodePacked(uint8(1)); // nativePayment = true\n        (requestId, ) = requestRandomnessPayInNative(\n            callbackGasLimit,\n            requestConfirmations,\n            numWords,\n            extraArgs\n        );\n        \n        // 存儲請求信息\n        _requests[requestId] = RandomRequest({\n            requester: msg.sender,\n            requestType: requestType,\n            data: data,\n            fulfilled: false,\n            randomWords: new uint256[](0)\n        });\n        \n        // 如果是用戶相關請求，更新映射\n        if (requestType == RequestType.HERO_MINT || requestType == RequestType.RELIC_MINT) {\n            (address user, , , ) = abi.decode(data, (address, uint256, uint8, bytes32));\n            userToRequestId[user] = requestId;\n        }\n        \n        // 退還多餘費用\n        if (msg.value > totalFee) {\n            payable(msg.sender).transfer(msg.value - totalFee);\n        }\n        \n        emit RandomRequested(requestId, msg.sender, requestType);\n    }\n    \n    /**\n     * @notice 授權合約（實現 IVRFManager）\n     */\n    function authorizeContract(address contract_) external override onlyOwner {\n        authorizedContracts[contract_] = true;\n        emit AuthorizationUpdated(contract_, true);\n    }\n    \n    // ============================================\n    // Chainlink VRF 回調\n    // ============================================\n    \n    /**\n     * @notice VRF Coordinator 回調函數\n     * @dev 由 VRF Wrapper 調用\n     */\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        RandomRequest storage request = _requests[_requestId];\n        require(!request.fulfilled, \"Already fulfilled\");\n        \n        request.fulfilled = true;\n        request.randomWords = _randomWords;\n        \n        // 處理不同類型的請求\n        if (request.requestType == RequestType.HERO_MINT || \n            request.requestType == RequestType.RELIC_MINT) {\n            // 解析數據\n            (address user, , , ) = abi.decode(request.data, (address, uint256, uint8, bytes32));\n            // 存儲用戶的隨機數\n            userRandomWords[user] = _randomWords;\n        }\n        \n        // 回調請求合約\n        try IVRFCallback(request.requester).onVRFFulfilled(_requestId, _randomWords) {\n            // 成功\n        } catch {\n            // 失敗但不回滾，確保隨機數被存儲\n        }\n        \n        emit RandomFulfilled(_requestId, _randomWords);\n    }\n    \n    // ============================================\n    // 管理函數\n    // ============================================\n    \n    /**\n     * @notice 設置授權合約\n     */\n    function setAuthorizedContract(address _contract, bool _authorized) external onlyOwner {\n        authorizedContracts[_contract] = _authorized;\n        emit AuthorizationUpdated(_contract, _authorized);\n    }\n    \n    /**\n     * @notice 設置回調 Gas 限制\n     */\n    function setCallbackGasLimit(uint32 _limit) external onlyOwner {\n        callbackGasLimit = _limit;\n    }\n    \n    /**\n     * @notice 設置請求確認數\n     */\n    function setRequestConfirmations(uint16 _confirmations) external onlyOwner {\n        requestConfirmations = _confirmations;\n    }\n    \n    /**\n     * @notice 設置平台費用\n     */\n    function setPlatformFee(uint256 _fee) external onlyOwner {\n        platformFee = _fee;\n        emit PlatformFeeUpdated(_fee);\n    }\n    \n    /**\n     * @notice 設置 VRF 請求價格\n     */\n    function setVrfRequestPrice(uint256 _price) external onlyOwner {\n        vrfRequestPrice = _price;\n        emit VRFPriceUpdated(_price);\n    }\n    \n    /**\n     * @notice 提取 BNB\n     */\n    function withdrawBNB() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No BNB to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n    \n    // ============================================\n    // 輔助函數\n    // ============================================\n    \n    /**\n     * @notice 獲取總費用（動態計算）\n     * @return 總費用（BNB）\n     */\n    function getTotalFee() public view returns (uint256) {\n        // 估算一個典型請求的費用\n        uint256 estimatedVrfPrice = i_vrfV2PlusWrapper.calculateRequestPriceNative(\n            callbackGasLimit,\n            1 // 估算 1 個隨機數\n        );\n        return estimatedVrfPrice + platformFee;\n    }\n    \n    /**\n     * @notice 獲取請求狀態\n     */\n    function getRequestStatus(uint256 requestId) external view returns (\n        bool fulfilled,\n        uint256[] memory randomWords\n    ) {\n        RandomRequest memory request = _requests[requestId];\n        return (request.fulfilled, request.randomWords);\n    }\n    \n    /**\n     * @notice 檢查合約是否被授權\n     */\n    function isAuthorized(address _contract) external view returns (bool) {\n        return authorizedContracts[_contract];\n    }\n    \n    // Receive function\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}